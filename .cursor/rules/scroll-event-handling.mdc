---
globs: *.tsx,*.ts
description: Scroll event handling patterns for preventing event bubbling
---

# Scroll Event Handling Best Practices

## Preventing Scroll Event Bubbling

When implementing components that need to prevent scroll events from bubbling to parent containers, use this established pattern:

### 1. Native Event Listeners
Always use native `addEventListener` instead of React synthetic events for scroll prevention:

```typescript
useEffect(() => {
  const element = elementRef.current
  if (!element) return

  const handleWheel = (e: WheelEvent) => {
    e.stopPropagation()
    e.preventDefault()
  }

  // Use capture mode and passive: false for maximum control
  element.addEventListener('wheel', handleWheel, { passive: false, capture: true })

  return () => {
    element.removeEventListener('wheel', handleWheel, { capture: true })
  }
}, [dependency])
```

### 2. Key Options Explained
- `passive: false`: Allows calling `preventDefault()` to stop default scroll behavior
- `capture: true`: Ensures the event is handled in the capture phase, giving higher priority
- Always clean up event listeners in the useEffect cleanup function

### 3. Implementation Examples
This pattern is used in:
- [VSCodeDiff.tsx](mdc:src/components/VSCodeDiff.tsx) for tooltip scroll prevention
- [FileDiffModal.tsx](mdc:src/components/FileDiffModal.tsx) for modal scroll handling

### 4. Common Use Cases
- Modal dialogs that shouldn't scroll the background
- Tooltips that shouldn't trigger parent scrolling
- Custom scrollable containers within larger scrollable areas
- Fixed position elements that need to control their own scrolling

### 5. Testing Considerations
- Test with different scroll speeds and directions
- Verify that parent containers don't scroll when child elements are scrolled
- Check behavior on different devices (mouse wheel, trackpad, touch)
- Ensure accessibility is maintained (keyboard navigation still works)